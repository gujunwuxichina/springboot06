package com.gujun.springboot06;

public class HighConcurrencyDeal {

    /*
        高并发开发：
        为了克服高并发所带来的超发问题，提出了乐观锁、悲观锁、使用Redis等解决方案；

     */

    /*
        悲观锁：
        超发问题根本在于共享的数据被多个线程所修改，无法保证其执行顺序，从而出错；
        如果一个数据库事务读取到产品后，就将数据锁定，不允许别的线程进行读写操作，直至当前数据库事务完成才释放锁，就不会出现超发问题；
        做法很简单，只需在查询共享数据的sql中最后加上 for update即可；
        因为并发的数据库事务要等待释放锁才会执行，所以性能上会损失；
     */

    /*
        乐观锁：
        是一种不使用数据库锁和不阻塞线程并发的方案；
        就是一个线程一开始先读取数据库数据，先保存起来，这些数据成为旧值，然后去执行业务逻辑，等到需要对共享数据修改时，会先将保存
        的旧值和数据库中的值进行比较，如果一致，则认为数据没有被修改过，否则就认为数据已经被修改过，不再修改任何数据；
        不过会引发ABA问题：
        为此可以增加版本号来解决，版本号只能递增不能递减，通过比较版本号是否一致来判断数据是否可信；
        但是由于加入版本号问题，所有大量请求得到失败结果；对此还可以引入冲入机制，即一旦更新失败，就重新做一次；
        原理是一旦发现版本号被更新，不是结束请求，而是重新做一次乐观锁流程，直至成功为止；
        但也带来了新问题：可能会造成大量sql被执行；对此会采用限制时间；
        但是按限制时间重入也有缺点，就是系统会随着自身的忙碌大大减少重入次数，为此有新增了限制重入次数的办法；
     */

    /*
        redis处理：

     */

}
